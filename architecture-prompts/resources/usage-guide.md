# 使用指南 - AI 架构设计提示

一份实用的指南，教你如何使用 AI 工具应用 Eskil Steenberg 的黑盒架构原则，以实现最大的开发速度。

## 🎯 快速上手工作流

### 1. 选择你的场景

- **新项目** → 从 `claude-prompt.md` (规划) 开始
- **重构现有代码** → 从 `claude-code-prompt.md` 开始
- **调试/测试问题** → 使用 `cursor-prompt.md`
- **架构审查** → 使用 `claude-prompt.md`

### 2. 准备你的上下文 (推荐)

使用 AI 上下文工具提取相关的代码上下文：

```bash
# 对于 JavaScript/TypeScript 项目
npx repomix --include "src/**/*.{js,ts,jsx,tsx}" --output context.xml

# 对于 Python 项目
git clone https://github.com/jimmc414/onefilellm.git
cd onefilellm
python onefilellm.py ./your-project/src/ --output context.xml

# 只针对特定文件夹
npx repomix --include "src/components/**" --output component-context.xml
```

### 3. 应用合适的提示

从本仓库复制相关的提示，粘贴到你的 AI 工具中，然后附上你的代码上下文和具体问题。

## 📋 详细使用场景

### 场景一：规划一个新项目

**工具**: Claude (网页版/桌面版)
**提示**: `claude-prompt.md`

**示例会话**:

```
[在此粘贴 Claude 规划提示]

我正在构建一个实时聊天应用，需要支持：
- 多种消息类型 (文本、图片、文件)
- 用户在线状态指示器
- 消息历史持久化
- 移动和网页客户端

你能用黑盒原则帮我设计这个应用的架构吗？
```

**你将得到**:

- 模块分解 (如 MessageStore, PresenceManager, ClientAdapter 等)
- 组件之间的接口规格
- 风险评估和缓解策略
- 带有优先级的实施路线图
- 团队组织建议

### 场景二：重构复杂代码

**工具**: Claude Code
**提示**: `claude-code-prompt.md`

**示例会话**:

```
[在此粘贴 Claude 代码提示]

[附上你项目的 context.xml 文件]

这个 React 组件已经增长到 500 多行，复杂的状么管理、DOM 操作和 API 调用都混在一起。我该如何用可替换的黑盒模块来分解它？
```

**你将得到**:

- 黑盒边界的识别
- 具体的重构步骤
- 新的接口设计
- 每个模块的代码示例
- 重构后代码的测试策略

### 场景三：调试和测试策略

**工具**: Cursor
**提示**: `cursor-prompt.md`

**示例会话**:

```
[在此粘贴 Cursor 提示]

[附上相关的代码文件]

我的支付模块和用户认证模块之间存在集成问题。它们各自的测试能通过，但一起使用时就失败了。我应该如何用黑盒原则来调试这个问题？
```

**你将得到**:

- 针对模块边界的调试方法论
- 测试隔离策略
- 接口验证方法
- 模拟/桩代码 (Mock/stub) 建议
- 根本原因分析指导

## 🔧 高级工作流

### 上下文 + 提示的黄金组合

**最强大的方法**: 将 AI 上下文提取与架构提示相结合

1.  **提取专注的上下文**

    ```bash
    # 专注于特定问题领域
    npx repomix --include "src/auth/**" --include "src/payments/**" --output modules-context.xml
    ```

2.  **应用架构分析**

    ```
    [Claude 代码提示]

    [附上 modules-context.xml]

    这两个模块紧密耦合，导致了一些问题。
    我如何在它们之间创建清晰的黑盒接口？
    ```

3.  **增量式实施**
    - 使用 AI 的建议，一次重构一个模块
    - 在过渡期间保持现有接口不变
    - 隔离地测试每一项变更

### 多阶段架构演进

**阶段一：战略规划** (`claude-prompt.md`)

- 定义整体系统架构
- 识别主要的模块边界
- 规划实施阶段

**阶段二：实施** (`claude-code-prompt.md`)

- 构建独立的模块
- 创建清晰的接口
- 实现黑盒边界

**阶段三：测试 & 调试** (`cursor-prompt.md`)

- 验证模块接口
- 调试集成问题
- 优化性能

### “聚焦文件夹”方法

非常适合大型代码库：

1.  **识别问题文件夹**

    ```bash
    # 为特定文件夹提取上下文
    npx repomix --include "src/components/editor/**" --output editor-context.xml
    ```

2.  **使用架构提示进行分析**

    ```
    [Claude 代码提示]
    [附上 editor-context.xml]

    这个文件夹包含了我们的文本编辑器组件。它们变得越来越难维护和测试。我该如何用黑盒原则来重构它？
    ```

3.  **实施建议的变更**
    - 一次重构一个组件
    - 保持向后兼容
    - 彻底测试接口

## 🎨 提示定制技巧

### 针对你的领域进行调整

在任何提示中添加领域特定的上下文：

```markdown
## 额外上下文

你正在为一个 [医疗保健/金融科技/游戏] 应用工作，其中：
- [有特定的法规要求]
- [有性能限制]
- [有安全考虑]
- [有集成需求]

在考虑这些领域约束的同时，应用黑盒原则。
```

### 针对特定技术的调整

**对于 React 项目**:

```markdown
## React 特定注意事项

- 组件应该是具有清晰 props 接口的黑盒
- 状态管理应该被隔离在模块内部
- 副作用应该被包含并且是可测试的
- Context 不应泄露实现细节
```

**对于后端 API**:

```markdown
## API 特定注意事项

- 每个端点都应代表一个清晰的业务能力
- 数据库交互应隐藏在服务接口之后
- 外部 API 依赖应被包装并且是可模拟的
- 错误处理在所有模块中应保持一致
```

## 🚨 常见陷阱与解决方案

### 陷阱一：过度工程化

**问题**: 创建了太多微小的模块
**解决方案**: 使用“一人原则”——每个模块都应能由一个开发者维护

### 陷阱二：泄露性抽象

**问题**: 接口暴露了实现细节
**解决方案**: 测试一下你是否能仅凭接口就完全重写实现

### 陷阱三：上下文过载

**问题**: 包含了太多代码上下文，让 AI 感到困惑
**解决方案**: 专注于与你问题相关的特定文件夹或文件

### 陷阱四：忽略依赖关系

**问题**: 没有考虑模块之间如何连接
**解决方案**: 总是询问关于接口设计和集成点的问题

## 📊 衡量成功

### 前后对比指标

跟踪这些改进：

- **每个模块的代码行数** - 应该减少
- **接口复杂度** - 更少的公共方法/函数
- **测试隔离性** - 模块能否独立测试？
- **替换难度** - 重写一个模块有多难？
- **开发者上手速度** - 新开发者能多快开始贡献？

### 架构质量清单

应用提示后，验证：

- [ ] 每个模块都有单一、清晰的职责
- [ ] 接口有文档，使用起来显而易见
- [ ] 实现细节被完全隐藏
- [ ] 模块可以在不了解内部的情况下被测试
- [ ] 外部依赖被包装，而非直接使用
- [ ] 任何模块都可以仅凭其接口被重写

## 🔄 迭代策略

### 持续架构改进

1.  **每周架构评审**
    - 挑选一个正在引起问题的模块
    - 应用合适的提示
    - 实施一个建议的改进

2.  **新功能集成**
    - 在构建新功能前，使用 `claude-prompt.md` 进行规划
    - 确保新代码遵循黑盒原则
    - 如有需要，更新现有接口

3.  **由 Bug 驱动的重构**
    - 当 Bug 出现时，使用 `cursor-prompt.md` 理解根本原因
    - Bug 的出现通常意味着糟糕的模块边界
    - 修复架构，而不仅仅是症状

## 💡 专业技巧

### 与其他工具结合

- **与 GitHub Copilot 结合**: 让 Copilot 生成代码，然后用这些提示来正确地组织它
- **与 IDE 集成**: 在你的 IDE 中保存提示片段以便快速访问
- **文档**: 使用架构分析的见解来改进你的 README 和 API 文档

### 团队协作

- **分享架构决策**: 将 `claude-prompt.md` 的输出作为设计文档
- **代码评审焦点**: 评审接口和模块边界，而不仅仅是实现
- **新人上手**: 新团队成员可以使用这些提示来理解代码库的架构

### 长期维护

- **架构债务**: 定期使用这些提示进行评审和重构
- **技术迁移**: 黑盒架构使得技术迁移更加容易
- **为扩展做准备**: 架构良好的模块能更好地处理增长

记住：目标不是立刻获得完美的架构，而是获得一个在项目增长过程中能保持可维护性的架构。迭代地使用这些提示来持续改进你的代码库结构。
