0:02
应大家的要求，我来做一个关于如何构建大型软件项目的讲座。
0:08
我将谈谈我的设计哲学，以及我是如何思考大型项目的结构的。
0:13
我最近在一个演讲中提到，任何软件都应该能由一个人写出来，很多人不理解或有疑问。
0:20
所以这次算是那次演讲的后续。
0:27
如果你想看那个演讲，可以去 Better Software Conference 的频道，我会把链接放出来。
0:32
但这次会更深入，讲讲如何实际构建软件。
0:38
那么，我们开始吧。
0:45
今天我将非常、非常简略地，可以说是挥挥手就开发三个软件。
0:52
我要做一个视频编辑器，一个数字医疗保健系统——因为这似乎是每个政府都会搞砸的东西——
0:59
然后我还要造一架喷气式战斗机。
1:06
这些都是复杂的东西。
1:14
在你开始打字说我根本不懂这些之前，我得说明一下，
1.21
我显然不会涉及所有细节。这些都是巨大的软件项目，有很多细微之处，而且我也不是这些领域的专家。
1:27
所以，我并不是在教你如何编写这些特定的软件，而是想告诉你我如何着手处理各种软件项目。
1:33
对于任何这些项目，你都需要很多具备领域专业知识的人，
1:42
需要对需要解决的问题有清晰概念的人等等。我懂一点点，所以我会以此为起点，
1:47
来谈论如何开发软件。但是，如果你想知道任何细节，比如我从未为喷气式战斗机开发过软件，
1:54
所以，请对这些内容持保留态度。这不是重点。
2:02
好的，这次是关于过程，而非具体细节。
2:08
那么，我们来谈谈结构。我们如何组织事物？这是主要问题。
2:13
当我们规划一个这样的大项目时，我们希望为某些事情进行优化。
2:21
我希望优化的是“可靠性”(dependability)。你想要一个能永远持续、永不崩溃的项目。
2.33
你希望它是“可扩展的”(extendable)，这样你就可以添加新功能和能力，应对变化。
2:41
你希望有“团队可扩展性”(team scalability)，这很大程度上归结为，你希望每个部分都由很少的人，最好是一个人来负责。
2:48
因此，如果他们与其他人隔离开来，你就不需要开那种所有人都参与的大型团队会议。
2:55
你想创建很多个小项目，而不是一个大项目。
3:00
显然，你还想要“开发速度”(development velocity)。你希望能把事情做完，并且不希望像通常软件开发那样，
3:06
工作时间越长，速度越慢。你不想要那样。你想要一直保持相同的速度。
3:14
而其中很大一部分就是降低风险。
3:21
事情总会出错，这就是生活。但你想要减少它。
3:27
所以你必须思考你的风险状况。什么最有可能失败？你必须非常努力地避免那些问题。
3:33
这里有一些可能变化的东西。
3:38
平台可能会变，无论是通过 API 变化，还是他们改变了服务条款，或者不再受用户欢迎。
3:45
所以你想把自己与变化的平台隔离开来。
3:52
还有语言实现。如果你今天用最时髦的语言写东西，
3:58
但你构建的系统要存在20年甚至更久，比如一架喷气式战斗机要用50年，
4:03
一个医疗保健系统可能也差不多。很多视频编辑器都是80、90年代的。
4:08
所以，让软件能存活几十年非常重要。
4:14
因此，你需要确保你用的语言在未来仍然有编译器。
4:20
然后显然还有变化的硬件、变化的优先级。你未来可能需要今天不需要的东西。
4:25
你还可能失去人员。如果你最牛的程序员离开了怎么办？
4:32
这些都是你真正需要担心的事情。
4:38
很多小的失败几率，加起来就是一个大的失败几率。
4:44
很多可能很容易修复的小问题，如果数量足够多，发生得足够频繁，
4:50
事情就会变得非常非常烦人。
4:57
所以，即使很多人说“哦那是个小修复，一个编译错误而已，随手就改了”。
5:02
也许是这样，但如果你正在做某件事，突然你的软件因为别人加了个小问题而停止工作，
5:08
你就得切换上下文，停下手中的活，去修另一个东西，
5:16
你知道，这会让工作陷入停顿。你得去看你不懂的代码之类的。
5:22
所以你真的真的要避免哪怕是最小的“减速带”，因为随着项目变大，你会遇到越来越多的减速带和问题。
5:29
我是一个C程序员。我用C89。这是你能拥有的最可靠的语言。
5:34
它能在任何地方编译，能永远持续，它就是好用。
5:41
我目前正在尝试文档化我称之为“可靠C”(dependable C)的东西，
5:49
也就是C语言中你可以信赖的那个子集。主要是C89，如果你想非常安全的话。
5:56
但C99的某些部分也相当安全。
6:03
不过，这些规则其实和你用什么语言关系不大。
6:08
你可以应用所有其他的原则。你可以用C++，可以用Python，真的可以用任何语言来写。这不是特定于语言的。
6:14
但我确实认为语言是风险之一，就像Python从2到3的时候把所有东西都搞坏了。
6:21
如果你有数百万行Python 3代码，然后他们决定搞个Python 4并破坏向后兼容性，那你就有大麻烦了。
6:29
所以，这就是那条规则：“今天写五行代码，比今天写一行、未来再回来修改要快得多。”
6:36
你真的想“完成”你的代码。你想写那种永远不会坏的代码。
6:43
如果这意味着多打点字，对你想要的东西更明确一点，那是好事。
6:48
因为你现在写的时候就在思考它。而五年后回去，试图弄清楚它干了什么并修复它，
6:55
即使是个小修复，也真的真的很难。而且它会停止工作。
7:02
你想要的是真正可靠的东西。当你完成代码时，你知道你几年内都不用回来修它，这才是关键。
7:11
所以，你想把你的软件模块化。
7:18
如果你要让多个人工作，你就需要模块化。那我们怎么做呢？
7:23
在我看来，模块应该几乎是“黑盒”(black boxes)。它们做什么，应该通过API或协议来暴露。
7:30
你和它对话，它有一个你可以文档化、清晰易懂的接口。
7:36
然后每当你想用它时，你就通过那个接口。你实际上不需要知道幕后发生了什么。
7:44
有人写好了它，它坚如磐石，就是能用。你不需要知道它做什么，永远不需要看代码。
7:52
你不需要与API之外的任何东西集成。API是有文档的。
7:58
这就是为什么我喜欢C语言的头文件，因为你可以有大量的代码，
8:03
然后把它隐藏在一个头文件后面，说“这是你所有能用的函数，这是你访问所有功能的方式”。
8:11
我怎么实现的你不用关心，因为我已经为你解决了。
8:17
所以，这意味着一个模块可以是一个人。
8:23
这真的很关键，就是你可以把所有东西拆分成小模块，每个模块可以是一个人。
8:28
你有多个模块，这就是我说的“任何软件都应该能由一个人写出来”的意思。
8:34
你把它拆分成模块，模块小到一个人能写。
8:39
然后在某个时候，有人会来写那个“应用”，他们通过把一堆别人写好的现有模块组合起来，
8:45
用这些东西来完成任务。
8:50
这就是为什么我们今天讨论的这些软件，本质上都可以由一个人来写。
8:57
是的，显然你可以让优秀的程序员完成一个模块再做下一个，那也行。
9:04
但规则是，你真的应该避免让多个人必须在同一个模块上工作。
9:09
你可能会让很多人一起设计一个模块，或者决定API应该是什么样的，
9:16
但我真的认为让一个人来实现是最好的。
9:22
有些模块会是“高级”的，有些是“初级”的。会有难实现的模块，也会有简单的东西。
9:29
所以你要好好考虑，把难的模块给你资深的员工，简单的给初级的。
9:35
这是一个很有趣的事情。如果那个模块出问题了，或者写得很糟糕怎么办？
9:40
嗯，如果你为它设计了一个好的API，你实际上可以
9:46
用一个新的黑盒来重新实现那个API，用不同的算法，不同的所有东西，
9:52
而所有使用它的软件仍然能工作。
10:00
这意味着，如果一个软件由某个人负责，如果那个人走了，
10:05
你可以从头重写它，然后逐步迁移到新版本。这真的非常强大。
10:11
我们来谈谈视频编辑器。我们要谈一个基本的视频编辑器。
10:17
它是一个带有UI的原生应用。我们从这里开始。
10:23
你想要的架构栈大概是这样的：
10:29
你需要一个平台层，用来打开窗口之类的。你需要能画线之类的。
10:36
然后你需要处理文本。文本可以在绘图库里。
10:42
然后你需要一些UI组件，这样你才能为你的应用做UI。文本也可以在UI库里，我的UI库里就是这样。
10:49
你真的应该包装你的平台层。
10:56
这里的想法是，任何不属于你的东西，也就是平台，
11:03
你不应该直接和它对话。你应该在它周围做一个包装层。
11:09
有很多现成的包装层，比如SDL就是一个你可以用的。
11:16
但即使你用的是在线的、开源的、通常很好的东西，你仍然无法控制它。
11:21
你不知道他们的开发方向，你不知道你是否会需要别的东西，
11:28
如果你需要添加功能，你不知道他们会不会接受你的补丁。
11:35
所以，即使你用的是很好的东西，你还是想包装它，
11:40
这样你的代码里就不会有一堆直接调用你无法控制的代码。
11:48
我可以给你们看，这是 `betray.h`，我的包装层的头文件。
11:54
它包含各种东西，但它允许你打开窗口，获取输入，很多事情。
12:01
它最初是在SDL之上实现的，但那是SDL 1.0，很久以前了，它没有我想要的所有功能。
12:07
所以我做了另一个后端，是win32的，后来我们又支持了很多其他操作系统。
12:13
但这真的给了你对平台的控制权。
12:19
然后你一定要写一个测试应用。
12:25
我这里正好有我的。这是我的小测试应用。
12:32
这是一个最小化的应用，只打开一个窗口，读取鼠标指针，画点东西。
12:38
这里有些按钮能做些事。我可以点这里，这里有个小窗口。
12:45
如果我滚动窗口，我能收到所有事件。
12:51
这在你尝试把这个API移植到另一个平台时非常有用。
12:55
因为如果你在构建一个有数百万行代码的巨大视频编辑器，
13:01
你不想把所有代码都移植到新平台。你想从非常小、非常简单的东西开始。
13:09
所以这样做超级有用。通常你是在写平台层的时候写这个，因为你需要点东西来测试你做的是否正确。
13:14
这是一个很棒的小东西。我可以给你们看，等一下，这是一张
13:21
同样软件在安卓上运行的截图。它还在很多其他平台上运行过。
13:28
当你移植到一个新平台时，第一件事就是让这个跑起来。
13:33
这是它的文件，不是很大，但它画了些东西，基本上尝试了API的所有功能。
13:38
通常当你实际实现这个的时候，你会注释掉大部分东西。
13:45
你从只打开一个窗口开始，当那个能工作了，你就会说“好了，现在我取消注释读取鼠标指针的部分”。
13:51
随着你一步步做，最终整个应用都能在新平台上运行。
13:59
在做平台层时需要考虑一些事情。
14:04
具体是什么取决于你的应用想做什么。比如你想要什么样的输入，
14:11
屏幕分辨率，长宽比，缩放比例。
14:18
你想要复制粘贴吗？文件选择器？“安全区域”越来越重要，
14:26
基本上就是说，你的窗口可能这么大，但也许你在手机上，
14:33
有个刘海挡住了，或者有圆角。所以你不应该在那里放文本。
14:42
你需要能检测屏幕的哪些区域对于UI或信息是安全的。
14:50
然后你可能想支持多用户。我的层不仅支持来自多个输入设备的输入，
14:58
还支持来自多个用户的输入。
15:04
比如，你可以有两个手柄，那就是两个不同的用户在输入。
15:11
因此我的API支持像一台电脑连接两个鼠标和两个键盘这样的事。
15:16
所以在我的UI工具包里，一个用户可以用一个鼠标指针在一个文本框里点击并开始打字，
15:25
而另一个用户在另一个文本框里点击并开始打字，输入的文字会去到正确的窗口。
15:32
现在还没有平台真正支持这个。Windows不支持，我也不知道有哪个平台支持。
15:39
但如果未来有平台支持，我所有的应用就都能直接工作，这超级有用。
15:46
然后你还想整合很多功能。
15:53
你想把平台上所有零散的东西变成一个东西。
16:00
比如，在我的例子里，所有的按钮都是一样的。
16:05
不管是在手柄上、键盘上还是鼠标上，都一样。所有的指针都是一样的。
16:11
所以鼠标指针和触摸是一回事。基本上，我们有多点触控，多指针，它们都一样。
16:19
触摸基本上就是一个当你没点击时不会移动，并且只有一个按钮的鼠标指针。
16:25
轴向输入也是一样，比如摇杆或者踏板。
16:32
这会变得更复杂一点，我们后面再谈。
16:39
现在你想做一个绘图层。
16:46
你需要基本的东西来画UI。你想画线、表面、图片，也许还有着色器、几何体，
16:53
这取决于你想做什么。
17:00
这是我的，叫Relinquish。它构建在OpenGL之上，但设计上可以在Vulkan或任何后端上运行。
17:07
我希望某个时候能实现它。
17:15
然后你想做文本。显然，所有应用都需要文本。
17:20
这里有个例子，我会如何实现它。你可以实现最简单的文本。
17:26
你可以找一个网上的字体，比如这个位图字体。
17:31
你把它加载进来，做一堆小方块，然后画出来。
17:37
如果你实现了这个，你可以做一个简单的函数来画文本。
17:44
你可以非常非常容易地画出来。
17:46
既然你有了这种黑盒思维，你实际上可以做一个画文本的黑盒。
17:51
它可以非常简单，就像位图文本一样，不做任何复杂的事。
17:58
但一旦你有了这个，别人就可以开始写使用文本的UI了。
18:05
然后你可以进去，实现真正的字体加载，实现各种好东西。
18:12
你可以做TrueType字体，抗锯齿，字距调整等等你不在乎的东西。
18:17
这是一个非常重要的事情。就是说你可以给别人一个实际上还没完成的东西的API。
18:24
它能画文本，但画得不好看。但这没关系，因为别人不需要好看的文本就能开始构建界面。
18:31
他们只需要文本。
18:37
我这里展示的这个API其实不太好，因为它没法让你做所有想做的事。
18:41
我来展示一下我画文本的函数，它其实是众多函数之一。
18:46
比如，你想给它字体，字母大小，间距，文本内容。
18:53
而且你不想文本是ASCII，你想要UTF8之类的。
19:00
你想要颜色，还想要一个长度指定符，这样你就可以只打印一部分文本。
19:05
然后你希望它返回文本的长度。
19:12
所以即使你用那个简陋的、没有字距调整的字体来实现，你仍然可以为它构建这个接口。
19:17
也许字体参数暂时是null，表示默认字体。也许只有一个字体，你不能选。
19:24
但你仍然在那里放一个字体参数。
19:30
这意味着开始写代码的人可以像它已经完成了一样去写。
19:36
然后当它真正完成时，文本会开始变得很好看，但实际上没人需要重新实现他们所有写了文本功能的地方。
19:41
所以这是你真的需要学习如何“向前思考”的。
19:47
你想想未来我们需要什么，并真正避免实现“暂时够用”的东西。
19:53
因为你想完成事情。如果你不得不，
19:59
比如文本，你可能不想做阿拉伯语，那是从后往前写的，或者韩语之类的。
20:05
也许你的产品团队等不及你实现那个，因为他们需要发布产品。
20:11
那么你可以实现一个简单的，但永远不要实现一个“暂时够用”的API。
20:17
API是一样的。你想清楚了，我某个时候要做韩语，所以我们做一个对韩语够用的API。
20:23
然后人们可以用那个，即使你现在画不出韩语，未来也可以，他们不用改代码。
20:31
这真的非常非常重要。
20:38
然后你可以做同样的事，构建一个UI工具包。我有一个。
20:44
这可以被模块化。我的是一个大的UI工具包，但你可以把它模块化成按钮之类的。
20:51
我认为做一个UI工具包相对容易。按钮很容易实现，滑块也容易。
20:57
UI里唯一有点棘手的是文本输入。
21:03
所以，不依赖操作系统，不依赖平台，不是什么大事。
21:10
特别是如果你在做一个可移植的应用。
21:16
如果你得去弄清楚三个不同平台是怎么做滑块的，
21:22
你需要的时间比自己实现一个滑块要多。所以，就自己做一个滑块吧。
21:27
好了，现在我们有了这个，算是我们的基础层。
21:30
你可能会注意到一件事，就是这些其实和视频编辑器没关系。
21:37
这只是你可以用来构建任何东西的东西，任何桌面或移动应用。
21:42
所以，一旦你做好了这个，这实际上是你自己、你公司的超能力。
21:46
对我来说，那些大型的、价值数十亿美元的软件公司居然没有拥有这个，真是太神奇了。
21:51
他们应该有这个，这样他们就能快速地做出他们未来想做的任何产品。
21:58
你不应该依赖操作系统来画文本。
22:05
即使你是个小公司，你也应该能做到这个。如果你是个大公司，你绝对应该把这个作为你的工具包的一部分。
22:11
这些都是辅助库。
22:14
你真的想把尽可能多的东西放进辅助库，因为辅助库可以被任何项目复用。
22:19
比如文件解析、物理引擎、脚本、数据存储、网络，各种各样的东西。
22:27
比如网络，我有Testify，一个库，做了所有你需要做的事情。
22:33
它能搞清楚你在什么样的网络上，能做各种事情。
22:40
它用端口转发协议打开端口，能找到对等节点，能做各种事。
22:46
它真的非常强大。
22:53
这基本上意味着我再也不用关心socket API了。
23:00
我可以在底层改进它，比如连接能力，做某些事情的能力，
23:04
而不用改变任何使用它的应用。
23:11
好了，现在我们到了核心部分，就是你真正开始构建你正在构建的应用。
23:18
这也是这次演讲的大部分内容，如何构建一个核心。
23:25
我们编辑的是什么？这个应用做什么？我们如何泛化它做的事情？
23:31
在我看来，一个视频编辑器不是编辑视频的东西，它编辑的是一个“时间线”。
23:36
它是一条时间线，一堆相互叠加的片段，它们在时间中，
23:44
然后你可以从那生成一个视频。你有一堆片段，有输入数据，
23:50
然后你对那个输入数据进行重新排列，然后得到一个输出。
23:57
所以，我们可以把这个想成是带有动画参数的时间线上的片段。
24:02
因为我们需要参数。我们想放大，想调色，想做标题，想做各种事。
24:09
所以那些会是这些片段的参数。
24:14
所以，一切都是片段。现在我们把它变得非常泛化了。
24:20
这真的很关键。如果你能泛化事物，你就能做出非常好的软件。
24:26
比如Unix，一切都是文件。
24:32
这意味着Unix里很多东西都是兼容的，因为这个接受一个文件，这个输出一个文件，
24:39
你可以把它们连在一起，然后就能工作。
24:45
像Houdini这样的软件，我这里有张截图，
24:50
它基本上是一个节点图。整个软件，一个大型视觉效果包，
24:57
基本上就是一个大的节点图，每个节点上都有参数。这就是Houdini。
25:01
我还想提一下Notch，因为他们太棒了，也是同样的东西。
25:06
它是一个做视觉效果的节点图。
25:12
这些都是你可以把你整个应用放进去的基本结构。
25:17
如果你拿Unreal来说，就变得更复杂了。
25:23
Unreal是C++，一堆C++，但也有蓝图，还有带资产的场景图。
25:28
这意味着你不能那么容易地泛化所有东西，
25:35
你最终会遇到这样的情况：“哦，我们用蓝图做了这个，但我们希望它是C++的”，
25:41
或者“我们用C++做了这个，但现在我们没法在蓝图里以我们想要的方式访问它”，
25:48
或者“这是个资产还是蓝图？什么是数据？”，它变得有点复杂。
25:53
这不是直接批评Unreal，Unreal做的是非常非常复杂的事情。
26:00
所以有时候你没法像这样简化事情。世界不是你想要的那么简单。
26:05
所以你想要思考的，也是我经常思考的，是我称之为“原生体”(primitives)的东西。
26:11
原生体这个词是我从计算机图形学借来的。
26:17
我有计算机图形学背景，所以我用多边形之类的东西思考。
26:23
我们想谈谈多边形。如果你想做几何体，你可以用多边形来定义它们。
26:30
典型的，这是一个犹他茶壶，一堆多边形，小三角形或四边形。
26:35
这是一种非常简单的表达3D数据的方式。但你也可以想其他方式。
26:42
你可以用NURBS，它们是数学曲线。它们可以做出真正的曲线，而多边形不能。
26:48
所以如果你想做一个汽车建模软件，NURBS要好得多。
26:53
但NURBS在数学上非常非常复杂，不容易处理，你需要很多代码来管理它们。
27:00
你也可以做这样的东西，这是Teardown。
27:05
Teardown里所有东西都是用体素(voxels)，小方块，构建的。
27:11
这意味着做碰撞检测非常容易，做破坏效果容易，做一堆用三角形超级难做的事情都容易。
27:17
但另一方面，像用一堆小方块做一个光滑的表面，几乎是不可能的。
27:23
所以，有得有失。
27:30
然后，我们可以更进一步。这是符号距离场(SDF)，一种新的、热门的做数学形状的方式，
27:36
它给你一堆其他的优点和缺点。
27:43
或者我最喜欢的，细分曲面。这是来自我的细分曲面建模软件，
27:48
它给你一个多边形网格，然后被圆滑成一个光滑的或比较光滑的表面。
27:56
但你选择哪一个，真的决定了你构建的是什么样的软件。
28:02
一些更高级的软件，像Maya之类的，它们允许你有多种不同的几何体表示方式。
28:08
但那也意味着你的软件会变得非常复杂，
28:14
因为现在有些功能你可以在NURBS上做，但在多边形上做不了，
28:20
或者有些事你可以在体素上做，但在多边形上做不了。
28:26
所以你得来回转换，然后就迷失了，变得非常复杂。
28:33
所以如果你能找到一个“原生体”来存储你的数据，
28:39
一个一致的、对所有东西都适用的原生体，那真的非常非常好。
28:44
我们再谈谈Unix。Unix其实是一个很好的例子。
28:51
在Unix里，一切都是文件，基本上是文本文件。
28:57
这意味着你可以用grep来搜索一段文本并找到它，这很棒。
29:02
但它对某些东西不管用，比如你没法在一个包含《卡萨布兰卡》的MP4文件里grep一句台词。
29:08
你找不到所有好的台词，因为grep处理的是文本，不是视频。
29:15
所以通过限制自己说“一切都是文本文件”，你可以用文本文件做很多事，
29:21
但当你想做视频编辑、图像编辑或者不是文本的东西时，
29:27
Unix和命令行就不是一个好的接口了。
29:32
这里我想谈谈原生体和结构的区别。
29:39
在Unix里，你可以说我们使用的“结构”是用带管道的命令行在应用之间传递东西。
29:46
但从A移动到B的东西，数据的“格式”，是文件，那就是“原生体”。
29:53
如果我们改变原生体，我们可以做一个命令行系统，你可以在A和B之间管道传输视频，
30:00
那原生体就是视频，但我们仍然有相同的结构。
30:05
或者我们也可以有一个结构，比如一个节点图的UI，但在连接线里我们传递的是文本。
30:11
所以我们用的是相同的原生体。
30:16
这是你需要思考的两个不同的东西，当你选择如何设计时。
30:21
这里有个例子。Photoshop的结构是一堆图层，
30:27
虽然在现代Photoshop里不完全是这样，因为它很复杂，但我们可以把它想成是一堆位图的图层。
30:32
而Nuke，一个合成软件，我这里有张截图，
30:39
这是一个来自Nuke的节点图，让你能合成视频。
30:46
它的原生体仍然是位图。仍然是位图在这个东西里移动。
30:51
但它现在是一个树状结构。
30:57
所以，这两个，它们不总是位图，它们也能做曲线之类的，
31:02
但大体上你可以把它们想成是两个不同的东西。
31:06
在我们的例子里，当我们要做一个视频编辑器时，
31:11
我们说我们想做的所有工具都操作“片段”。
31:16
当你在时间线上移动时，你基本上是在编辑一个片段，或者改变那个片段的参数，
31:22
这就是你做的所有事。所有UI，所有东西都做这个。这就是这个应用的本质。
31:27
所以我们想构建一个黑盒来存储这个信息，
31:32
存储一个时间线，并有一个API让我们能访问它。
31:38
有一个实际存在的例子是OpenTimelineIO，一个开放的Python API，用来创建一个时间线。
31:44
你可能会构建你自己的。
31:50
当你构建这个保存你所有应用数据的核心时，
31:55
你可以强制执行一些保证。比如，在我们的例子里，我们想做某些事。
32:01
比如，我们不希望片段有负数时间，或者我们希望片段永远不要比它们使用的素材长。
32:08
我们可能想要时间上的一致性，我们可能想要任何我们认为重要并想保证的东西。
32:15
这意味着当API调用这个核心时，它们不用关心那些事。
32:20
它们知道它们将要得到的数据会满足某些要求，并且是“干净”的。
32:25
另一件你可能想做的事是“撤销”。
32:31
其他应用可以只说“像这样改变片段”，
32:36
然后这个存储容器会自动管理，
32:42
找出与上一个版本的变化，并能撤销它们。
32:48
所以你想把那个构建到你的核心结构里。
32:53
好的，我们想支持什么样的片段？我们想加载各种视频。
33:00
那我们怎么做？如果核心有一个你可能想要的每一种片段、每一种视频格式、每一种效果的定义，
33:06
那这个核心就太庞大了，一个人不可能写完。
33:12
所以我们真的真的不想那样做。
33:17
所以我们想构建一个插件架构。我们想构建一个API，
33:23
让一段代码可以进来说，“我能做这个，我能给你看MP4的视频，
33:30
我会给你关于长度、分辨率之类的信息，我需要你告诉我你希望它以什么速度播放，
33:38
默认是1倍速”，你知道，你想描述这个插件。
33:43
这个插件，所以你基本上得到这样的东西，这是我的结构。
33:50
你有一个带一堆插件的核心。然后我们有我们的UI工具包。
33:57
这里的核心实际上没有UI，不做任何事。它只是一个核心，
34:02
你可以读入插件，然后访问插件。
34:06
我们来看看接下来你想写什么。嗯，你想写一个“启动器”。
34:12
你想写一个东西，它启动平台，启动核心，加载所有插件，并实际做点事。
34:18
在我的例子里，呃，我看看，我好像漏了点什么。
34:24
我稍后会给你们看一些这个的演示。
34:30
在我的例子里，这可能就够了。
34:36
你可能只需要所有的UI和API都在这里。你只为它写一个UI。如果那是个简单的应用。
34:42
我来给你们看一个简单的应用。
34:48
我写过一个应用，工作方式有点像这样。这是Stellar。
34:55
实际上是Stellar 2.0，一个控制灯光的应用。
35:02
我可以给你们看一点它是如何工作的。这里是一个3D世界。
35:06
这里我们有一个灯具。现在我在网络上找，那里应该有一个灯具。
35:13
我可以创建一个灯具的集合，这给了我输入。
35:20
然后我有一堆这些东西，它们是做事情的，这些是插件。
35:26
所以这个应用里所有的效果都是插件。
35:31
比如我可以创建一个球体，然后把它连接到这个。
35:36
现在你可以看到我这里有一个球体了。
35:42
我实际上可以移动这个球体，改变参数，让它有点淡出，改变颜色，
35:50
或者任何我想要的。
35:54
然后这个应用正好是一个节点图，如你所见。
35:59
我可以引入其他东西，比如我可以在这里创建一些运动，
36:06
把这个连接到运动，然后让它循环。
36:13
现在它动得非常快。
36:20
现在我创建了一个简单的效果。
36:26
我可以引入其他东西，比如我可以引入一个颜色渐变。
36:31
我要拿这个渐变，把它变小一点。
36:39
我要把这个连接到渐变上。现在它得到一个单色。
36:46
然后我们用这个东西来驱动这个渐变。
36:52
现在我可以在这里设置一个颜色，在这里设置另一个颜色。
36:59
我们把它设成黑色。
37:06
现在我可以重新映射，做各种事情。
37:13
这就是这个应用做的事情。
37:20
但如果我们看看底层，你会发现实际上所有这些都是插件。
37:28
甚至这个也是一个插件，一个内置的魔法插件，用来和灯具对话。
37:35
然后这些都只是描述它们做什么。
37:42
所以如果我们看看这个的内部，
37:48
这个API就是你构建UI的基础。你基本上说“创建一个效果”，
37:54
然后你可以创建节点，你说你想要哪个节点。
38:00
你可以得到描述符，告诉你它有什么参数，
38:06
然后你可以设置那些，你基本上可以构建一个UI。
38:13
所以这个小东西就是你构建整个UI所需要的一切。
38:20
所以核心可以很小，然后你在此之上构建一个UI。
38:27
这意味着我可以重建UI而不用重建核心。
38:32
关于这个应用的一件事，你可能也想对视频编辑器做，
38:39
就是你可以把你的核心拿出来，做一个单独的应用。
38:46
比如，你有你的视频编辑器，然后你保存一个视频编辑文件。
38:51
也许你想有一个命令行工具，可以直接拿那个文件来处理视频，
38:58
因为你想在服务器上运行。
39:05
那么你可以有核心，然后跳过所有UI，所有打开窗口的东西，
39:10
只做一个小小的命令行东西，而应用的所有处理核心都与UI完全分离。
39:16
我们实际上可以，我给你们看一个插件。
39:23
这是一个文件，是一堆插件。
39:30
你创建一个插件，要做的是，它们存在于一个单独的DLL里。
39:36
这意味着应用本身保持很小，
39:42
你可以让人写DLL，然后你可以一个一个地添加它们，
39:49
那些人基本上可以完全隔离地工作。他们不需要认识写核心的人。
39:54
他们只需要遵循一个API，做任何他们想做的插件。
40:00
而应用中的大部分接口，大部分功能，都存在于那些插件里。
40:06
这里有一个简单的方式，你说，“嘿，我想做一个球体”，就是我们看到的效果。
40:12
它会输出颜色，它是形状的一部分，一些你可以在UI里放的文本，描述它做什么。
40:19
然后你列出它的所有输入，它们叫什么，默认值是什么，
40:24
一点关于你可能想如何绘制它的UI提示。
40:31
然后你还给它一个函数。如果我们去那个函数，
40:37
这就是实际做计算的函数。
40:43
这让你能非常非常快地实现新功能。
40:50
实际上，为了显得更技术宅一点，
40:57
这个API，这种插件API，我为Betray，我的平台库，也做了。
41:03
所以，如果我们看这里，这是平台。
41:10
这是一个为Xbox手柄，基本上是Windows手柄，做的插件。
41:15
这意味着当我构建我的系统时，我不需要为Windows链接特殊的代码。
41:23
那是一个可以单独构建的独立插件。
41:29
因此，我没有对那个的依赖。
41:35
我只有一个小的DLL有依赖，而系统没有它也能正常工作。
41:41
它只是一个可选的东西。
41:46
这意味着你可以有很多小的依赖，但你永远不需要所有它们来构建。
41:54
你几乎不需要任何依赖来构建项目，但之后你可以添加你想要的东西。
42:01
好的，我们继续。
42:08
你想呈现信息和能力，
42:14
这几乎是我总能遇到的一个模式。
42:20
当你为事物构建结构时，你希望事物能说出它们能做什么，
42:27
以及它们能告诉你什么。
42:35
这里有一个非常简单的洗衣机。如果你看这两个结构体，我在做什么？
42:43
你可以把它想成是，我是一个洗衣机，我当前正在运行，
42:51
你有一个枚举表示你在什么模式。我当前的温度是多少？我当前的负载是多少？
42:57
我还剩多少秒？
43:04
如果你得到这个信息，以及这个结构的信息，
43:10
如果一个洗衣机能说“这些是我能告诉你的关于我自己的参数”，
43:15
那就是你构建一个UI所需要的一切。你可以构建一个与此配合工作的应用。
43:21
然后同样的事情是，你需要一个结构体，基本上说“这些是你需要发给我来告诉我做什么的参数”，
43:28
比如，你需要告诉我我是否应该运行，以什么模式，什么温度。
43:34
我真的无法理解为什么做物联网的人搞不定这个。
43:42
但真的，你不需要知道它是一个洗衣机来构建这个系统。
43:48
你只需要知道“这是它想告诉你的东西，这是它需要知道的东西”。
43:54
而那是一个洗衣机、一个烤面包机还是别的什么，都无所谓。
44:01
我实际上正在做一个叫Marshall的项目，我希望做一个新视频来介绍它，它会解决很多这类问题。
44:08
好的，这是我们更新后的设计。我们可能有一个核心，一堆插件，
44:15
但我们也可能有一个启动器UI，然后有它的插件。
44:21
所以如果我们有一个复杂的UI，我们可能有一个启动器来启动它，
44:26
然后说，“好了，这里有一堆面板。显示信息的面板，
44:33
它们本身就是插件，它们和其他插件对话，做图形处理，
44:38
因此我们可以拆分UI。
44:45
我们可以让一个工程师只做时间线，一个做视频视图或调色，
44:52
或者所有不同的部分，我们可以把它们拆分开，而不是一个代码库。
44:58
好的，我们来构建一个医疗保健系统，你会发现它非常非常相似。
45:06
首先显然你想搞清楚你的需求。
45:11
你想搞清楚什么是原生体，什么是流经医疗保健系统的数据。
45:16
也许是病历？人们会这么想。可能不是最好的。
45:23
我认为我们应该有“医疗保健事件”。
45:29
因为如果你想想，你的病历就是一堆事件，
45:35
从你出生开始，每次你去看医生都是一个事件。
45:43
这很棒，因为你还可以有未来的事件，比如你的预约。
45:48
你还可以用不同的方式访问数据。
45:54
比如你可能想说，“我想要今天这个诊所所有的医疗保健事件”。
46:00
这意味着我想访问今天所有要来这里的人，以及他们什么时候来，
46:06
但我不想看他们的完整病历。
46:13
我可能只是某个地方的文员，我不能读所有信息，但我需要知道谁要来，
46:18
我需要知道日程什么时候有空，我需要知道那个。
46:24
所以我们就用这个。我们说我们处理一堆事件。
46:30
然后我们做和之前完全一样的事情。我们构建一个黑盒。
46:36
人们开始会问，“你会选哪种存储？SQL还是blah blah blah还是亚马逊？”
46:42
对我来说，这完全是错误的方式。
46:48
你想做的是，“我们存储什么，以及我们如何访问？”
46:53
而它实际上如何存储，是一个黑盒。
47:00
我可能会把它存储在某个我找到的好的开源东西上。你可以自己写，或者别的什么。
47:06
但对系统的所有用户来说，那都无所谓。
47:12
这意味着你实际上可以随时改变你的存储。你可以重写它，换到别的地方去。
47:18
你不想把自己锁定在亚马逊或某个特定供应商上。
47:24
你甚至不想把自己锁定在MySQL这种稳定开源的东西上。
47:31
谁知道你未来想用什么呢？
47:36
所以，真的，对于系统的用户，他们不应该需要知道，
47:42
他们不应该需要做SQL调用，因为后面可能没有SQL。
47:47
你需要为你如何访问这个东西制作你自己的接口。
47:54
这意味着你灵活得多。
48:00
好的，一旦你构建了这个，你能做的第二件事是，
48:05
一旦你在你的黑盒之间有了一个API，
48:11
你可以拿任何旧系统，因为你猜怎么着，你的医疗保健系统可能有一个你想摆脱的古老的东西，
48:16
但你不想一次性切换。很多这样的项目都失败了，因为他们一次性切换。
48:23
而切换非常非常痛苦。所以为什么要那样做？
48:29
你要做的是写一小段“胶水代码”，用你的访问API和旧的访问API。
48:34
然后就在它们之间移动所有数据。
48:42
当你得到一个新事件或新数据到你的系统时，你把它移动到旧系统。
48:48
当旧系统得到新东西时，你把它读出来，放到新系统里。
48:55
现在什么都不会坏了。现在你可以逐步迁移。
49:00
这非常有用，你不想有这种破坏性的改变，说“我们从系统A切换到系统B”。
49:07
不，不，你想同时拥有两个系统。
49:14
然后你可以在此之上开始做其他的胶水代码。
49:20
比如，你有这个黑盒。也许你想有多个API来使用它。
49:27
也许你想要一个C的API，但嘿，没人会写C。
49:32
也许硬核的人想写一个高性能的C的东西，但大多数开发者不会用C。
49:39
所以你可以在它之上做一个C++的API。你可以做一个Python的绑定。
49:46
你可以在其上做各种绑定，它们都用同一个API。
49:53
然后你可以让你硬核的C++大神去写完美的C++东西。
50:00
实际上，没有完美的C++，但无所谓。
50:06
你可以让不同的人写这些胶水代码，给人们多种访问系统的方式，
50:12
而不需要使用核心API。
50:18
然后当然，当有新语言、新能力或人们想访问的新方式时，
50:25
你可以写新的胶水代码。
50:32
然后你可以在那之上写东西。所以在你的胶水之上，你可以说，
50:39
“好了，现在我们从黑盒里拿出数据，然后通过互联网发送出去，
50:46
现在我们可以写一个做非常具体的事情的应用”。
50:53
所以我们可以有成百上千个不同的应用，给不同种类的医疗保健人员，
50:58
给做医疗保健相关事情的机器，
51:04
它们都可以通过互联网报告回来，它们可以用它们自己的方式对话，
51:09
只要最终能进入其中一个接口就行。
51:14
现在我们可以建一个网站。比如我们用Python。
51:20
我们可以拿一个Python API，然后生成一个网站，
51:26
你可以用浏览器来访问信息。
51:32
所以你可以像这样扇形展开，长出一棵东西的树，
51:39
但所有东西都通过这个中央的黑盒。
51:46
实际上，那个黑盒可能运行在一台机器上，或一千台机器上，
51:53
但对用户，对这些应用来说，它只是一个你对话的API，
52:01
你不需要知道后台发生了什么，是否有一个大的服务器基础设施来存储所有这些数据，
52:06
它如何被切片和处理。你都不用关心，因为这对你来说是一个API。
52:12
好的，我们来造一架喷气式战斗机。你会发现它几乎是一样的。
52:18
我们这里有很多东西。我们有很多传感器，武器系统，能力无穷。
52:25
而很多这些能力，我们甚至不知道它们是什么，因为如果你今天造一架喷气式战斗机，
52:31
它会存在50年。所以谁知道25、30年后，
52:36
你想在这东西上放什么样的导弹、无人机或传感器。
52:41
所以即使你可能可以调查这个，可以有一些非常聪明的人告诉你所有这些事，
52:47
即使他们也无法知道。所以你没法在知道它将是什么的情况下架构一个系统。
52:53
好的，我们可能能用什么原生体？
53:00
我们可能会说，这里的原生体是“世界的状态”。
53:06
医疗保健系统关心历史，而喷气式战斗机主要关心“现在”正在发生什么。
53:12
它想知道所有联系人在哪里，敌人在哪里，我还有多少燃料，
53:19
我还剩多少子弹，哪个雷达能探测到哪个物体，
53:25
风速、温度是多少，所有这些传感器和东西给你的信息。
53:31
你还想关心一些特定于飞机的东西。
53:38
比如，你想要“置信度”。你对这个东西有多信任？
53:45
在战争中，你可能不信任所有东西。
53:51
你想要“准确度”。如果你有两个不同的东西测量同一个东西，
53:57
你想知道那些东西的准确度。
54:02
你想知道“来源”是什么。如果你从某个东西得到温度，你想知道那个温度的来源。
54:07
你想知道“格式”是什么。你可能有多种格式的东西，
54:14
比如我想知道这个敌人的位置。我是想要相对于战斗机的位置，
54:20
还是想知道它在世界上的位置？这是两回事，两种问一个东西在哪里的方式。
54:25
然后我想要一堆“能力”。
54:31
比如，你把一个导弹放到飞机上，你想知道这个导弹能做什么。
54:38
当你发射它时，你希望那个能力消失。
54:45
你希望人们能添加新能力，新导弹，新东西。
54:50
然后系统应该能理解你现在有了一个新能力。
54:55
然后你可能还想有像“损坏”这样的东西，
55:02
比如如果有人把一个传感器炸掉了，准确度可能会降到零。
55:09
好的，你又想构建一个核心，一个黑盒来存储这个。
55:14
你要做的是，你做一个权威核心。你做一个核心，它有“根据所有传感器和东西，这就是世界的样子，这就是当前状态”。
55:20
但你会有很多小电脑到处都是，很多系统，每个雷达，
55:26
每个显示器，到处都会有电脑。
55:32
所以所有那些都需要知道状态。那么你需要一个协议，
55:38
让它们可以“订阅”信息。
55:43
你可能想要一个订阅者模型，比如某个引擎想知道湿度，
55:50
想知道燃料多少，或者高度之类的，但它不需要知道你有多少雷达联系人。
55:55
那对引擎不重要。它不关心。
56:01
所以你基本上想，而且你飞机上有些部分会有非常强大的电脑，
56:06
有些部分只有微控制器。
56:12
所以你希望能够订阅你想要的信息。你希望那被推送通知给你。
56:17
你可能有不同的频率，你多常想要信息之类的。
56:23
一旦你有了那个订阅者，你就可以在你本地的芯片上，
56:29
在你本地的内存里，有一个部分的世界状态。
56:34
然后你可以用那个来做决定。
56:41
然后你甚至，当你构建这个系统时，你可以说，
56:47
“我们可能想有不同的方式来编码订阅者和权威核心之间的信息”，
56:53
因为我们可能有不同类型的电缆，不同类型的硬件连接器。
56:59
我们可能想支持多种，有不同的带宽，不同的要求。
57:05
但这仍然意味着，如果你在为这个东西构建一个设备，
57:11
你现在有一个稳定的API，一个你可以调用来了解情况和发送信息的API。
57:18
所以如果你在建一个雷达，你可以从系统获取湿度或任何你需要的东西，
57:24
然后你可以把你找到的所有联系人发送到权威核心，
57:29
权威核心可以把它发送给飞行员或可视化系统或屏幕或平视显示器，
57:34
或任何对那个信息感兴趣的系统。
57:40
好的，所以这里它不是一个存储系统，它是一个传递系统。
57:46
你把数据从飞机的一端传到另一端。
57:51
你当然也可以存储，如果那是一个需求的话。
57:57
这里有一个非常重要的事情，对所有这些项目都适用，
58:03
那就是如果你构建这样的东西，你要做很多“工具”。
58:10
比如，我们正在造一架新战斗机。我们还没想好它长什么样，但我们构建了这个核心。
58:15
我们会有所有这些不同的承包商和人来造导弹之类的，
58:20
他们都得以某种方式连接到这个东西上。我们怎么做？
58:26
他们不能，你怎么测试一个导弹，当飞行员要按的那个按钮还没做好的时候？
58:32
所以，你想要很多工具。
58:38
你希望能够把来自各种东西的输入都记录下来。
58:43
现在你有一个黑匣子记录器了。因为所有信息都通过这个东西。
58:49
所以你可以有一个小记录器，订阅所有信息并存储它。太棒了。
58:56
然后你可以有一个回放器。所以现在如果你有了第一次飞行，
59:02
你可以记录信息，然后你可以把它放到一个导弹上说“就这样做。
59:09
这是我们记录的一次真实飞行。这是它所有的数据。现在我们可以模拟那个”。
59:15
你可能想要一个Python API，因为也许你想，
59:20
当你测试某个东西时，你想模拟，比如某个东西消失了，
59:26
或者雷达不工作了。现在，你可以模拟东西。
59:31
你想要一个记录器，这样你可以看到发生了什么。
59:38
也许我只是在实现我的雷达，我需要能看到当雷达输出时，它输出正确，
59:43
进入系统的数据是正确的。只需要一个能把它打印在屏幕上的东西就超级有用。
59:49
你可以有可视化工具来看发生了什么。你可以有完整的模拟器。
59:54
我幻灯片上展示的所有这些代码，都是永远不会进入战斗机的，
1:00:00
但它们会非常非常有帮助，因为它允许所有这些试图为这个代码写东西的独立的人，
1:00:06
能够让代码做他们想做的事，这样他们就能测试他们的代码。
1:00:12
而那会帮助他们，一旦你真正开始把飞机组装起来，
1:00:18
所有这些部分相互对话。
1:00:24
如果你有一个导弹，你可以模拟驾驶舱做什么，
1:00:30
然后你可以记录导弹做什么，你可以把那个记录发送给做驾驶舱的人，
1:00:35
他们可以说，“好的，这就是我们期望从导弹那里得到的，当导弹发射时，
1:00:41
或者当导弹锁定目标时，或者导弹做的任何事”。
1:00:47
而这几乎适用于我谈到的所有项目。
1:00:53
几乎总是写一堆工具，让你可以从你的黑盒或核心盒里把数据拿出来，
1:01:00
让它们做事情。
1:01:06
在这一点上，这个黑盒实际上对飞机一无所知。
1:01:12
它什么也做不了。它不做航空电子学，不做目标跟踪。
1:01:17
它不可视化任何东西。它什么都不做。它只是传递数据。
1:01:23
我们实际上没有泄露任何秘密。
1:01:29
所以这个实际上可以是开源的。你可以把它给任何人。
1:01:34
你可以把它放到一个网站上说，“我们不会告诉你我们的导弹能飞多远，
1:01:40
但这是我们的导弹如何告诉系统它能飞多远的方式”。
1:01:45
这意味着你可以让所有这些承包商拿着这些手册，
1:01:51
出去尝试制造部件，你可以为制造适合这架飞机的东西进行公开招标。
1:01:56
而那让做事情容易得多。
1:02:02
因为你把所有秘密的东西都移除了。
1:02:07
你只是说“这是我们协作的方式”。
1:02:12
但实际的秘密，它如何工作，那取决于端点。
1:02:18
是的，是的，我知道没有真正的军方会把任何东西开源，
1:02:24
因为他们不理解这种事。
1:02:30
所以，现在人们可以添加所有这些部分。
1:02:35
现在人们可以添加传感器、武器、UI、连接器，各种东西。
1:02:41
但你会说，“这是一个糟糕的系统，因为现在我们所有东西都中心化了。
1:02:47
很糟糕。如果有人把运行核心的这台电脑炸了怎么办？
1:02:52
现在一切都完了。飞机坠毁，什么都不工作”。
1:02:58
没错。所以那是对喷气式飞机的要求。喷气式飞机有冗余系统。
1:03:03
所以你不能有一个所有东西都通过的中央核心。那行不通。
1:03:09
嗯，你可以很容易地构建多个核心。
1:03:15
这里的重点是，你可以有任意数量的核心，
1:03:20
位于很多不同的电脑上。你可以有很多这些系统之间的互连，
1:03:25
是冗余的，过度冗余的，但订阅者通过同一个API获取他们的信息。
1:03:31
所以这意味着你可以做一个非常简单的、易于实现的单核。
1:03:37
你可以实现那个，把它给每个人。他们可以开始做他们的导弹和设备和所有这些东西。
1:03:42
然后你可以花三年时间做这个先进的、有多个核心的系统，
1:03:48
这些核心会投票选出哪个是好的，能检测到哪个被炸了不工作了。
1:03:53
你可以构建所有那些，然后你向同样的人展示，“这是同一个API，
1:04:00
你获取同样信息的方式。它是一个直接的替代品”。
1:04:06
但不是等三年才得到那个，每个人都可以在六个月内得到。
1:04:12
而这正是这种黑盒思维的核心。
1:04:18
你可以重新设计内部核心，让它更复杂。
1:04:24
有时候你这样做，是因为你搞清楚了一些事，
1:04:30
有时候你这样做，是因为你需要把产品推出去。
1:04:35
这和我们做文本渲染完全一样。
1:04:41
我们从简单的文本渲染开始，但用的是同一个API，
1:04:47
然后我们后来做了漂亮的文本渲染，但那个API的用户不需要改变任何东西，
1:04:53
因为它就是能用。
1:04:58
好的，这里有个很酷的事。你现在可以把这个放到一辆坦克里。
1:05:04
它不一定非得在飞机里，它可以是任何东西。
1:05:09
如果你现在有了东西之间的连接，你可以把多架飞机连在一起，
1:05:16
它们可以共享这个信息。
1:05:21
所以不是说“我雷达锁定了，因为我的雷达找到了这个敌人”。
1:05:28
你可以说“我的邻居，另一架战斗机，找到了它”，或者“地面雷达找到了它”，
1:05:34
或者任何东西找到了它。都无所谓。
1:05:40
因为现在你有了一种沟通世界状态的方式。
1:05:45
你显然会有很多加密和很多东西来控制你想进出的东西。
1:05:50
但真的，一旦你有了这样的系统，你可以让它非常泛化。
1:05:56
它不一定非得在战斗机里。它可以是运输机，可以是坦克，可以是任何东西。
1:06:01
这意味着现在造导弹的人，他们可能想造一个可以从坦克发射、也可以从飞机发射的导弹，
1:06:07
而它们有相同的互连方式。
1:06:12
他们不需要写两个软件栈来控制这两个不同的东西。
1:06:18
事情变得更加互联。
1:06:23
即使会有很多不同，你实际上可以有相同的知识，
1:06:29
人们可以从不同的项目移动，他们知道，“哦，当我和系统对话时，
1:06:34
这是API，这是对话的方式”，即使我现在做的东西在硬件上或能力上，
1:06:40
和我上次做的完全不同。
1:06:45
好的，我们来总结一下。我讲了很长时间了。
1:06:51
这真的是，在我看来，所有软件设计的核心是“格式设计”。
1:06:57
而格式设计这个东西，学校里不怎么教，我希望有人能教。
1:07:03
我正在尝试写一篇关于这个的很长的文章和一本书，因为它真的是我们作为软件开发者做的事情。
1:07:08
如果你想想，很多东西都是格式。
1:07:14
API是一种格式。它是一种向某些代码发送调用的格式。
1:07:21
文件是一种格式。它是你如何在一个文件里存储东西的格式。
1:07:27
像网络这样的协议，是我如何以某种方式存储信息，那是一种格式。
1:07:34
编程语言是格式。它是你存储给电脑的指令的方式。
1:07:40
它也是，你用那种指令语言写，它是关于你能做什么、不能做什么来描述指令的一种格式。
1:07:45
所以格式非常重要。有一些你应该思考的事情。
1:07:50
一个是语义和结构的区别。
1:07:56
有时候，你只存储语义。比如，公制系统就只有语义。
1:08:01
如果我告诉你3米，每个人都能搞清楚3米是什么。
1:08:07
但我没有给你，我如何结构化那个？我是通过声音传过来的词语给你的。
1:08:13
那没有被定义。你可以把它写在一张纸上，可以打到电脑里。无所谓。
1:08:21
一米就是一米。我们描述了它在语义上意味着什么，
1:08:28
但没有描述我们在结构上如何发送它。
1:08:33
反过来，你可以想想像JSON这样的东西。
1:08:39
JSON是一种格式，它给你一个存储数据的结构，但没告诉你那些数据意味着什么。
1:08:45
它没有语义。它是一个东西的数组，但没说那些东西是什么。
1:08:50
所以你需要思考这些事，你把什么做成语义，什么做成结构。
1:08:56
很多时候你想要一个简单的结构，然后你可以有更复杂的语义，
1:09:02
因为那样你就可以复用读取语义的代码。
1:09:05
再比如JSON，一个JSON加载器可以加载任何JSON，
1:09:13
它可以存储医疗保健数据、武器数据或者视频编辑数据，都无所谓。
1:09:20
语义不重要，你可以用同一个加载器来处理所有这些东西。
1:09:25
那很有用。但它也有局限，因为是的，你能加载它，但你没法真的用它做什么，
1:09:31
因为你不理解它。你不知道它意味着什么。
1:09:38
格式需要是“可实现的”。这真的非常非常关键。
1:09:43
如果你想让所有这些人聚在一起工作，
1:09:50
如果API或格式太复杂，就会变得非常非常难。
1:09:55
如果我要做一个UI，而我试图为其做UI的数据是超级超级复杂的文本，
1:10:02
那我就会敷衍了事，做一个只能显示简单东西的UI。
1:10:07
然后你就会开始有不兼容性。人们开始说，“哦，我不支持那些东西”。
1:10:13
语言就是一个很好的例子。语言越大，实现就越少，
1:10:20
或者你的实现里bug越多，或者更多人读不懂，它变得越来越复杂。
1:10:26
更小的格式更容易实现，因此实现的质量通常更好。
1:10:33
所以你想把尽可能多的能力塞进一个简单的接口里，一个简单的格式里。
1:10:40
问题是，格式是双向的。
1:10:45
你保存一个文件，就得加载一个文件。你发送一个网络包，就得加载一个网络包。
1:10:52
如果你做一个复杂的API，就得有人去用那个复杂的API。
1:10:58
所以它像一门语言。你给别人搞得越复杂，
1:11:05
也给自己搞得越复杂。而且很多时候它是平方增长的。
1:11:11
如果你有10个不同的人，每个人想要一个功能，你就会得到10个功能，
1:11:18
现在每个人都得实现这个。
1:11:23
一个很常见的情况是，人们说，“我希望这个文件格式是……”
1:11:25
比如我们有多边形和NURBS，一些人觉得多边形好，一些人觉得NURBS好。
1:11:30
他们说，“我希望这是NURBS而不是……”。
1:11:38
但问题是，如果你同时支持多边形和NURBS，即使你想要NURBS，
1:11:43
你也得实现NURBS和多边形，而另一端也得实现多边形和NURBS。
1:11:49
所以现在两边都得实现他们不喜欢的系统和他们喜欢的系统。
1:11:56
所以每个人都得做更多的工作。实际上，最好是只选一个，
1:12:02
然后一些人会不那么开心。但即使他们不开心，他们也只需要实现一个东西，
1:12:08
而不是两个。即使，实现一个坏东西比实现一个坏东西和一个好东西要好。
1:12:15
那是更多的工作。所以你真的想让它尽可能小。
1:12:23
所以，“做出选择”。这非常重要。
1:12:28
很多人在格式问题上，就像是，“看，我的格式能做一百万件事”。
1:12:33
每当我看到那个，我就觉得，“你的格式要失败了，因为没人会去实现所有那些事”。
1:12:38
还有，管理约束。我能要求什么？这个格式的要求是什么？
1:12:45
如果我知道某些事，那就有帮助。
1:12:51
如果我知道所有来自战斗机核心的数据都是公制的，那太好了。
1:12:56
我可以那样做。或者即使我不喜欢公制，也许核心让我选，
1:13:01
我知道我可以被保证，如果我想要英尺它就给我英尺，如果我想要米它就给我米，
1:13:09
核心会为我处理那个。那太好了。我可以依赖那个。我不用想它。
1:13:17
思考交互。这是一个非常核心的事。
1:13:22
如果我们做一个视频编辑器，我们有一个时间线还是多个时间线？
1:13:29
我们有一个视频流还是可能想支持多个视频流？
1:13:36
我们支持立体视频吗？或者我们可能想有环绕我们的视频，比如50个显示器同时。
1:13:42
我们能编辑那个吗？
1:13:45
这非常重要，你有多少交互。
1:13:50
这几乎适用于所有事。这架战斗机能有一个雷达还是多个雷达？
1:13:55
或者它能有一个世界视图还是多个世界视图？
1:14:00
我应该能调出另一架飞机的世界视图吗？那有用吗？
1:14:05
还是他们活在同一个世界里？谁知道呢？这些是你必须决定的事。
1:14:12
很容易忘记把它们分开，导致交互太少，
1:14:18
但也很容易有太多层次的交互，以至于变得非常非常复杂，难以遍历和找到你想要的东西。
1:14:23
然后你想要“实现自由”。
1:14:28
我谈到医疗保健系统时稍微提过。
1:14:34
你基本上想说，“这是你和我谈论医疗保健的方式，但我如何实现医疗保健，不关你的事”。
1:14:41
有很多很多不同的方式来构建一个保存医疗保健数据的服务器集群，
1:14:46
我希望能够改变那个。我不想在我的API里说，
1:14:51
“哦，你可以发送你自己的SQL查询”。
1:14:56
如果我允许你那样做，那突然之间我就被要求有一个SQL查询语言。
1:15:01
如果他们开始为某些属性发送查询，那些属性就必须在那个SQL查询里并且能工作。
1:15:04
现在我就把自己锁定在后端的SQL上了。我现在完蛋了。
1:15:11
如果我想迁移到一个不使用SQL的后端，游戏结束。
1:15:16
所以你真的真的想确保你在这些东西之间加上锁。
1:15:22
基本上和文本渲染一样。你可以用位图做，可以用曲线或多边形或任何东西。
1:15:27
用户只是画文本。他们不需要知道它是如何实现的。
1:15:33
所以如果你想在未来改变我们的实现方法，我们可以做到。
1:15:40
好的，另一个大问题是插件系统。
1:15:45
你想要一个你把自己插进去的插件系统，还是你被插进去的？
1:15:53
我倾向于认为，如果你能做出能“被插入”的东西，那很好。
1:15:59
因为你不想让别的系统来支配你的代码如何工作。
1:16:06
我说过，你不想活在别人的世界里。你想活在你的世界里，并接受别人进入你的世界。
1:16:12
你不想进入别人的世界，活在他们的世界里。
1:16:18
当你做一个插件时，那个插件活在你的世界里，它活在它所插入的那个东西的世界里。
1:16:25
所以，如果你能做出不是插件的东西，那很好。
1:16:30
如果你能把它们做成独立的、不需要被插入到某个东西里的模块，那很棒。
1:16:37
但很多时候那是不可能的。所以，插件接口通常是正确的选择。
1:16:43
但如果可以，尽量做出可以被复用、被插入到其他东西里的东西。
1:16:49
就是这样。这就是我的演讲。
1:16:57
我非常感谢大家的观看。
1:17:05
你总能在Twitch上找到我的直播，在keels.com，或者我的Twitter和所有其他社交媒体上，@Kelsar。
1:17:11
感谢观看。再见各位。
